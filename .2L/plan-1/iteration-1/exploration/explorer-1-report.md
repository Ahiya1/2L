# Explorer 1 Report: Architecture & Structure

## Executive Summary

Iteration 1 requires building a real-time dashboard observability system for 2L orchestration. This involves creating three new files (event logger library, dashboard builder agent, generated HTML dashboard) and modifying one critical orchestration file (2l-mvp.md). The architecture follows a single-file HTML polling model with JSONL event stream, integrated into existing Bash-based orchestration. Complexity is HIGH due to meta-programming nature (2L improving itself), but architecture is straightforward: event logging to dashboard generation to polling display.

## Discoveries

### Dashboard Architecture Model

**Pattern: Single-File Polling Dashboard**
- Self-contained HTML file with inline CSS and JavaScript (under 500 lines total)
- No build dependencies or npm packages required
- Works offline via file:// protocol for multi-project isolation
- Polls .2L/events.jsonl every 2 seconds using fetch() API
- Renders 5 sections: header, metrics, active agents, MCP status, event log

**Rationale for this pattern:**
- Zero dependencies aligns with 2L constraint of minimal external tools
- file:// protocol ensures each project's dashboard is isolated
- Single file generation is tractable for dashboard builder agent
- Polling model avoids complexity of WebSockets or server-sent events
- JSONL format is append-only and safe for concurrent writes

### Event Logging Architecture

**Pattern: Bash Library with JSONL Append-Only Stream**
- Create lib/2l-event-logger.sh with log_2l_event function
- Source this library at top of 2l-mvp.md orchestration
- Events appended to .2L/events.jsonl (one JSON object per line)
- Format: timestamp, event_type, phase, agent_id, data

**Event types needed for Iteration 1:**
- plan_start - Orchestration begins (MODE detection)
- iteration_start - New iteration begins (with iter_id, global_iter)
- phase_change - Phase transitions (exploration to planning to building to integration to validation to healing)
- agent_spawn - Agent spawned (type, id, task description)
- agent_complete - Agent finished (type, id, status, duration)
- cost_update - Token/cost tracking (tokens, cost, cumulative)
- validation_result - Pass/fail/uncertain (status, issues count)
- iteration_complete - Iteration done (status, duration)

**Integration points in 2l-mvp.md:**
- After MODE detection (plan_start)
- At start of execute_iteration function (iteration_start)
- Before each phase print statement (phase_change)
- Around each spawn_task call (agent_spawn, agent_complete)
- After validation check (validation_result)
- At end of iteration (iteration_complete)

### Dashboard Builder Agent Architecture

**Purpose:** Generate the dashboard HTML file on first /2l-mvp run

**Agent specification needed:**
- Type: 2l-dashboard-builder
- Tools: Write (to create .2L/dashboard/index.html)
- Input: Project name from config, .2L directory path
- Output: Single HTML file with inline CSS/JS
- Triggered by: 2l-mvp.md checking if dashboard exists

**HTML structure to generate:**
Five main sections in the dashboard:
- Header: Project, plan, iteration, phase, status
- Metrics: Cost, elapsed time, tokens
- Active Agents: Currently running agents with duration
- MCP Status: Playwright, Chrome DevTools, Supabase
- Events: Last 20 events, newest first

JavaScript polling logic: fetch events.jsonl every 2 seconds, parse JSONL, update DOM with latest state, calculate derived metrics.

### File Structure and Components

**New files to create (3 total):**

1. ~/.claude/lib/2l-event-logger.sh (Bash library)
   - Purpose: Shared event logging helper
   - Functions: log_2l_event with 4 parameters
   - Appends to .2L/events.jsonl
   - Validates JSONL format, adds timestamp automatically
   - Lines: approximately 50 lines
   - Complexity: LOW

2. ~/.claude/agents/2l-dashboard-builder.md (Agent prompt)
   - Purpose: Agent that generates dashboard HTML
   - Tools: Write
   - Task: Create single-file HTML dashboard
   - Lines: approximately 200 lines (agent definition)
   - Complexity: MEDIUM (needs detailed HTML template guidance)

3. .2L/dashboard/index.html (Generated artifact)
   - Purpose: User-facing dashboard
   - Generated by: 2l-dashboard-builder agent
   - Structure: Single HTML file with inline CSS/JS
   - Lines: approximately 450 lines
   - Complexity: MEDIUM (polling logic plus rendering)

**Files to modify (1 total):**

1. ~/.claude/commands/2l-mvp.md (Main orchestration)
   - Changes needed: Dashboard initialization check, source event logger, add log_2l_event calls at 8+ orchestration points, handle dashboard spawn if missing
   - Impact: approximately 30 new lines across file
   - Risk: MEDIUM (touches critical orchestration file)

### Integration Points with 2L MVP Orchestration

**Integration Point 1: Dashboard Initialization**
- Location: After MODE detection, before orchestration begins
- Check if dashboard exists, spawn dashboard builder agent if missing
- Source event logger library if available
- Log plan_start event with level and plan_id

**Integration Point 2: Iteration Start**
- Location: In execute_iteration function
- Event: iteration_start
- Data: iter_id, global_iter, vision

**Integration Point 3: Phase Changes**
- Location: Before each phase print statement
- Event: phase_change
- Data: phase_name, iteration

**Integration Point 4: Agent Spawning**
- Location: Around spawn_task calls
- Events: agent_spawn (before), agent_complete (after)
- Challenge: spawn_task is synchronous in pseudocode, may need wrapper
- Data: agent_type, agent_id, task_description

**Integration Point 5: Validation Results**
- Location: After validation_report is read
- Event: validation_result
- Data: status, issues_count, iteration

**Integration Point 6: Iteration Complete**
- Location: After iteration finishes
- Event: iteration_complete
- Data: status, duration

### Browser Requirements and Compatibility

**Target Browsers:**
- Chrome/Chromium 90+ (primary dev environment)
- Firefox 88+
- Safari 14+
- Mobile: Chrome/Safari on iOS/Android

**JavaScript Features Needed:**
- fetch() API - Supported in all modern browsers
- Promises/async-await - Widely supported
- JSON.parse() - Universal support
- setInterval() - Universal support
- DOM manipulation (querySelector, innerHTML) - Universal

**CSS Features Needed:**
- CSS Grid - Supported in all modern browsers
- Dark theme via background-color/color
- Media queries for mobile responsiveness
- Flexbox for layout

**File Protocol Compatibility:**
- fetch() works with file:// protocol in most browsers
- CORS restrictions don't apply to local files
- Some browsers (Chrome) may need --allow-file-access-from-files flag
- Alternative: Use XMLHttpRequest if fetch() fails

**Offline Requirements:**
- No external CDN dependencies (Bootstrap, jQuery, etc.)
- All CSS and JS inline in HTML file
- No web fonts (use system fonts)
- No external images/icons (use Unicode emoji or CSS shapes)

## Patterns Identified

### Pattern 1: Append-Only Event Logging

**Description:** Event logging via Bash append to JSONL file

**Use Case:** Real-time event stream with concurrent write safety

**Example:**
Bash function that takes event_type, phase, agent_id, and data parameters. Generates timestamp using date command. Formats as JSON object and appends to events.jsonl using echo redirection.

**Recommendation:** Use this pattern. Append-only writes are atomic on POSIX filesystems, safe for concurrent access. JSONL (newline-delimited JSON) is standard for streaming logs.

### Pattern 2: Polling Dashboard with File Protocol

**Description:** HTML dashboard polls local JSONL file every 2 seconds

**Use Case:** Real-time dashboard without server infrastructure

**Example:**
JavaScript async function that fetches events.jsonl, parses text response, splits by newline, JSON.parse each line, updates dashboard. Called via setInterval every 2000ms.

**Recommendation:** Use this pattern. Simple, reliable, no dependencies. Works with file:// protocol for multi-project support.

### Pattern 3: Agent-Based Code Generation

**Description:** Use 2l-dashboard-builder agent to generate HTML instead of template

**Use Case:** Complex file generation that benefits from Claude's reasoning

**Example:**
In 2l-mvp.md, spawn task with type 2l-dashboard-builder. Provide detailed requirements: under 500 lines, dark theme, mobile-friendly, polls events.jsonl every 2 seconds, displays header/metrics/agents/MCP/events, works via file:// protocol.

**Recommendation:** Use this pattern. Dashboard HTML is complex enough (approximately 450 lines) that agent generation is more maintainable than a rigid template. Agent can reason about layout, styling, and polling logic.

### Pattern 4: Graceful Degradation for Event Logging

**Description:** Event logging is optional; orchestration works without it

**Use Case:** Backward compatibility with existing plans

**Example:**
Check if event logger library exists before sourcing. Set flag for event logging enabled. Wrap log calls in conditionals that check flag.

**Recommendation:** Use this pattern for backward compatibility. Existing plans without lib/2l-event-logger.sh continue working. New plans get event logging automatically.

## Complexity Assessment

### High Complexity Areas

**Dashboard HTML Generation** (Builder workload: 1 sub-builder if split)
- Why complex: Must generate 450 lines of valid HTML/CSS/JS in single file. Polling logic must handle JSONL parsing edge cases (incomplete lines, malformed JSON). Rendering must calculate derived metrics (active agents equals spawned but not completed). Mobile responsiveness requires media queries. Dark theme consistency across all elements.
- Estimated builder splits: Dashboard builder agent can likely COMPLETE, but might SPLIT into Sub-builder A: HTML structure plus CSS styling, Sub-builder B: JavaScript polling plus rendering logic.
- Mitigation: Provide detailed template structure in agent prompt to guide generation.

**Event Logging Integration in 2l-mvp.md** (Builder workload: 1 builder)
- Why complex: Must insert log_2l_event calls at 8+ orchestration points without breaking flow. 2l-mvp.md is 1176 lines of critical orchestration logic. Risk of introducing bugs in MODE detection, iteration loops, phase transitions. Must handle cases where event logging is disabled (backward compat).
- Estimated builder splits: Should NOT split (cohesive changes to single file).
- Mitigation: Use clear markers/comments to indicate insertion points; test thoroughly after changes.

### Medium Complexity Areas

**Event Logger Library** (lib/2l-event-logger.sh)
- Why medium: Pure Bash function with JSON formatting. Must handle special characters in data (escaping quotes). Timestamp formatting. Approximately 50 lines total.
- Straightforward implementation: Single function with append logic.

**Dashboard Builder Agent Definition** (agents/2l-dashboard-builder.md)
- Why medium: Agent prompt definition, not code itself. Must provide clear requirements and template structure. Approximately 200 lines of guidance.
- Straightforward: Follow existing agent prompt patterns (2l-builder.md as reference).

### Low Complexity Areas

**Dashboard Directory Creation**
- Trivial: mkdir -p .2L/dashboard

**Event Stream File Initialization**
- Trivial: Event logger creates .2L/events.jsonl on first write

**Dashboard Spawn Logic in 2l-mvp.md**
- Straightforward: approximately 10 lines checking file existence and spawning agent

## Technology Recommendations

### Primary Stack

**Event Logging: Pure Bash plus JSONL**
- Rationale: Zero dependencies (Bash is already required for 2L). JSONL is standard format for streaming logs. Append-only writes are atomic on POSIX filesystems. Easy to parse line-by-line in any language. No external tools needed.
- Alternatives considered: SQLite database (overkill, adds dependency), CSV format (harder to represent nested data), JSON array (requires reading/rewriting entire file).

**Dashboard Frontend: Vanilla HTML/CSS/JS (ES6)**
- Rationale: Single-file requirement eliminates build tools. No npm dependencies aligns with 2L constraints. Works offline via file:// protocol. Fast generation by dashboard builder agent. All modern browsers support ES6+ features needed.
- Alternatives considered: React/Vue (requires build step, overkill), Template engine (adds dependency), Server-side rendering (requires server, violates file:// protocol requirement).

**Dashboard Builder: Agent-Based Generation**
- Rationale: Dashboard HTML is complex but tractable for Claude agent. Agent can reason about layout, styling, and business logic. More flexible than rigid template. Follows existing 2L pattern (builders generate code, not templates).
- Alternatives considered: Static template with placeholders (less flexible), Multi-file dashboard (violates single-file requirement).

### Supporting Libraries

**None required.** All functionality implemented with Bash built-ins (echo, cat, date, source), standard Unix tools (mkdir, ls), and browser APIs (fetch, JSON.parse, DOM manipulation).

## Integration Points

### External APIs

None. Dashboard is fully offline, no external API calls.

### Internal Integrations

**Integration 1: 2l-mvp.md to lib/2l-event-logger.sh**
- How they connect: 2l-mvp.md sources event logger library at startup
- Data flow: 2l-mvp.md calls log_2l_event which writes to .2L/events.jsonl
- Coupling: Loose (event logging is optional, orchestration works without it)
- Testing: Test 2l-mvp.md with and without event logger present

**Integration 2: Dashboard HTML to .2L/events.jsonl**
- How they connect: Dashboard polls events.jsonl via fetch() every 2 seconds
- Data flow: events.jsonl (written by orchestrator) to dashboard (reads and renders)
- Coupling: Loose (event file schema is stable JSONL format)
- Testing: Test dashboard with empty events.jsonl, single event, 100+ events

**Integration 3: 2l-mvp.md to 2l-dashboard-builder agent**
- How they connect: 2l-mvp.md spawns dashboard builder agent if dashboard missing
- Data flow: 2l-mvp.md detects missing dashboard, spawns agent, agent writes HTML
- Coupling: Loose (one-time generation, no ongoing dependency)
- Testing: Test dashboard builder agent independently, verify HTML validity

**Integration 4: Dashboard HTML to config.yaml**
- How they connect: Dashboard reads config.yaml to display project name, plan ID
- Data flow: config.yaml (static) to dashboard reads on init and displays in header
- Coupling: Loose (config is read-only from dashboard perspective)
- Testing: Test dashboard with missing config.yaml (graceful degradation)

## Risks & Challenges

### Technical Risks

**Risk 1: Dashboard HTML Generation Complexity**
- Impact: Builder agent fails to generate valid HTML, or HTML doesn't work in browser
- Probability: MEDIUM (450 lines of HTML/CSS/JS is non-trivial)
- Mitigation: Provide detailed template structure in agent prompt with section markers. Include example polling code and rendering logic. Test generated HTML independently before integration. Fallback: Manual HTML template with placeholders if agent generation fails.
- Owner: Dashboard builder agent

**Risk 2: Event Logging Performance Impact**
- Impact: Frequent JSONL appends slow down orchestration
- Probability: LOW (append-only writes are fast)
- Mitigation: Keep event payloads small (under 1KB per event). Limit event types to essential orchestration checkpoints (8 types total). Test with 100+ events to measure performance. If needed: Batch events or reduce logging frequency.
- Owner: Event logger library

**Risk 3: JSONL Parsing Edge Cases in Dashboard**
- Impact: Dashboard crashes on malformed JSONL (incomplete line, invalid JSON)
- Probability: MEDIUM (edge cases during concurrent writes)
- Mitigation: Wrap JSON.parse in try-catch, skip malformed lines. Trim whitespace before parsing. Handle empty events.jsonl file. Display error count in dashboard footer for debugging.
- Owner: Dashboard JavaScript polling logic

**Risk 4: File Protocol Fetch Restrictions**
- Impact: fetch() fails with file:// protocol in some browsers
- Probability: LOW (most modern browsers support file:// fetch)
- Mitigation: Test in Chrome, Firefox, Safari. Fallback to XMLHttpRequest if fetch fails. Document browser requirement in dashboard. Provide workaround: --allow-file-access-from-files flag for Chrome.
- Owner: Dashboard JavaScript polling logic

### Complexity Risks

**Risk 1: 2l-mvp.md Modifications Introduce Bugs**
- Impact: Orchestration breaks, existing plans fail
- Probability: MEDIUM (touching 1176-line critical file)
- Mitigation: Make event logging calls non-blocking (wrap in if checks). Add clear comments marking insertion points. Test with existing plan (resume functionality). Test with new plan (full orchestration flow). Use version control to track changes.
- Builder should NOT split: All 2l-mvp.md changes are cohesive (event logging hooks)

**Risk 2: Dashboard Builder Agent Exceeds 500 Line Limit**
- Impact: Generated HTML is too large, violates requirement
- Probability: LOW (450 lines is target, 500 is max)
- Mitigation: Provide line count guidance in agent prompt. Minimize CSS (use simple dark theme). Minimize JS (efficient polling and rendering). Test generated HTML, measure line count.
- Builder might SPLIT if HTML generation proves too complex: Sub-builder A does HTML structure plus CSS (200 lines), Sub-builder B does JavaScript logic (250 lines).

## Recommendations for Planner

1. **Create event logger library first, then dashboard builder agent, then orchestration integration**
   - Rationale: Event logger is dependency for both dashboard and orchestration. Dashboard builder agent can be tested independently. Orchestration integration is last to minimize risk.
   - Recommended builder sequence: Builder 1 creates lib/2l-event-logger.sh (1-2 hours), Builder 2 creates agents/2l-dashboard-builder.md (1-2 hours), Builder 3 modifies 2l-mvp.md to initialize dashboard plus add event hooks (2-3 hours), Builder 4 (optional) tests and refines dashboard builder agent (1-2 hours).

2. **Dashboard builder agent should generate HTML in single pass, not split**
   - Rationale: HTML/CSS/JS are tightly coupled in single-file dashboard. Splitting into sub-builders would require complex coordination (structure before styling before logic).
   - If dashboard builder agent determines HTML is too complex (over 500 lines), it should simplify dashboard design (remove features) rather than split.

3. **Event logging integration in 2l-mvp.md must be backward compatible**
   - Rationale: Existing plans without lib/2l-event-logger.sh must continue working.
   - Implementation: Check if event logger exists before sourcing, wrap log calls in conditionals.
   - Testing: Test with old plan structure (no .2L/dashboard/, no events.jsonl).

4. **Dashboard should fail gracefully when events.jsonl is missing or malformed**
   - Rationale: Dashboard may be opened before any events are logged, or during concurrent writes.
   - Implementation: Handle empty file, catch JSON.parse errors, display "No events yet" message.
   - User experience: Dashboard shows "Waiting for events..." until first event is logged.

5. **Include dashboard URL in orchestration output**
   - Rationale: User needs to know where to open dashboard after /2l-mvp starts.
   - Implementation: After dashboard is created, print dashboard file URL.
   - Improvement: Generate clickable link in terminal (if terminal supports hyperlinks).

6. **Prioritize simplicity over features in dashboard v1**
   - Rationale: Goal is observability foundation, not feature-complete monitoring tool. Iteration 1 should prove the architecture works.
   - Minimum viable sections: Header (MUST HAVE), Event log (MUST HAVE), Metrics (NICE TO HAVE), Active agents (NICE TO HAVE), MCP status (OPTIONAL - can be removed if exceeds line limit).
   - If dashboard builder agent needs to reduce scope, remove MCP status section first.

## Resource Map

### Critical Files/Directories

**~/.claude/lib/** (NEW DIRECTORY)
- Purpose: Shared libraries for 2L system
- Contents: 2l-event-logger.sh (new in Iteration 1)
- Ownership: Shared across all 2L commands
- Creation: Builder 1 creates directory and library file

**~/.claude/lib/2l-event-logger.sh** (NEW FILE)
- Purpose: Bash helper for event logging
- Size: approximately 50 lines
- Functions: log_2l_event with 4 parameters
- Dependencies: None (pure Bash)
- Testing: Unit test by calling function directly, check .2L/events.jsonl output

**~/.claude/agents/2l-dashboard-builder.md** (NEW FILE)
- Purpose: Agent definition for dashboard generation
- Size: approximately 200 lines
- Structure: YAML frontmatter plus markdown agent prompt
- Dependencies: Follows agent prompt patterns from 2l-builder.md
- Testing: Spawn agent independently, verify generated HTML

**~/.claude/commands/2l-mvp.md** (MODIFIED FILE)
- Purpose: Main orchestration command
- Current size: 1176 lines
- Changes: plus approximately 30 lines (dashboard init plus event logging hooks)
- Risk: HIGH (critical orchestration file)
- Testing: Test full orchestration flow, verify resume functionality

**.2L/events.jsonl** (GENERATED FILE)
- Purpose: Append-only event stream for orchestration
- Format: JSONL (one JSON object per line)
- Size: Grows with orchestration (typically 50-200 lines per iteration)
- Lifecycle: Created on first log_2l_event call, persists for project lifetime
- Cleanup: Manual (user can delete to reset event history)

**.2L/dashboard/index.html** (GENERATED FILE)
- Purpose: User-facing dashboard HTML
- Generated by: 2l-dashboard-builder agent (one-time generation)
- Size: approximately 450 lines (HTML plus inline CSS plus inline JS)
- Lifecycle: Created on first /2l-mvp run if missing
- Updates: Regenerated only if deleted (not updated during orchestration)

**.2L/dashboard/** (NEW DIRECTORY)
- Purpose: Dashboard artifacts directory
- Contents: index.html (generated)
- Isolation: Per-project (each project has own dashboard directory)
- Access: Via file:// protocol

### Key Dependencies

**Bash 4.0+** (System dependency)
- Why needed: Event logger uses Bash features
- Availability: Pre-installed on Linux/macOS, available on Windows via WSL/Git Bash
- Fallback: None (Bash is required for entire 2L system)

**Modern Browser** (User dependency)
- Why needed: Dashboard uses fetch(), Promises, ES6 features
- Availability: User must have modern browser installed
- Fallback: None (dashboard is user-facing tool, not orchestration critical)

**POSIX Filesystem** (System dependency)
- Why needed: Atomic append-only writes for events.jsonl
- Availability: Linux, macOS, WSL on Windows
- Fallback: None (event logging may have race conditions on non-POSIX filesystems)

### Testing Infrastructure

**Testing Approach: Integration Testing**
- Rationale: Dashboard is integration between event logger, orchestrator, and browser. Unit tests are insufficient.

**Test 1: Event Logger Library**
- Setup: Create test script that sources lib/2l-event-logger.sh
- Execute: Call log_2l_event with various event types
- Verify: Check .2L/events.jsonl contains valid JSONL with correct timestamps
- Edge cases: Special characters in data, missing .2L directory

**Test 2: Dashboard Builder Agent**
- Setup: Spawn 2l-dashboard-builder agent independently
- Execute: Agent generates .2L/dashboard/index.html
- Verify: HTML file exists, is under 500 lines, passes HTML validation
- Edge cases: Missing project name in config, concurrent dashboard generation

**Test 3: Dashboard HTML Functionality**
- Setup: Manually create events.jsonl with sample events
- Execute: Open dashboard in browser (file:// protocol)
- Verify: Dashboard loads, polls events, displays data correctly
- Edge cases: Empty events.jsonl, malformed JSONL, 100+ events

**Test 4: Full Orchestration Integration**
- Setup: Create new test project with simple vision
- Execute: Run /2l-mvp (full orchestration flow)
- Verify: Dashboard auto-creates on first run, events stream to events.jsonl in real-time, dashboard updates every 2 seconds, all phases logged, dashboard displays active agents during building phase
- Edge cases: Resume after interrupt (dashboard persists, events continue appending)

**Test 5: Multi-Project Isolation**
- Setup: Create two test projects in separate directories
- Execute: Run /2l-mvp in both projects simultaneously
- Verify: Each project has own events.jsonl and dashboard, no cross-contamination
- Edge cases: Projects in nested directories, relative vs absolute paths

**Test 6: Backward Compatibility**
- Setup: Use existing plan structure from before Iteration 1 (no dashboard, no events)
- Execute: Run /2l-continue on old plan
- Verify: Orchestration works without event logging (graceful degradation)
- Edge cases: Old config.yaml format, missing lib/2l-event-logger.sh

## Questions for Planner

**Q1: Should dashboard builder agent be spawned synchronously or asynchronously?**
- Context: Dashboard initialization happens before orchestration begins. Spawning synchronously blocks orchestration start until dashboard is ready.
- Options: Synchronous (user sees message, then orchestration starts, ensures dashboard available immediately), Asynchronous (orchestration starts immediately, dashboard generated in background, user might miss early events).
- Recommendation: Synchronous (ensures dashboard is ready before events are logged)

**Q2: Should events.jsonl be rotated or archived at iteration boundaries?**
- Context: events.jsonl grows continuously. After 3-4 iterations, could be 500+ lines.
- Options: No rotation (single events.jsonl for entire plan lifetime, simpler, all history available), Iteration rotation (events.jsonl renamed at iteration end, keeps file sizes small), Size-based rotation (rotate when events.jsonl exceeds 1000 lines).
- Recommendation: No rotation for Iteration 1 (simplify implementation, add rotation in future iteration if needed)

**Q3: Should dashboard auto-refresh on file changes or continue polling?**
- Context: Polling every 2 seconds is simple but not instant. Browser File API could detect changes immediately.
- Options: Polling (simple, works in all browsers, 2-second latency), File watcher (complex, browser compatibility issues, instant updates).
- Recommendation: Polling (meets "real-time" requirement, 2-second latency is acceptable for monitoring)

**Q4: Should MCP status be hardcoded or dynamic?**
- Context: Dashboard shows 3 MCP servers. Status is static (always shows "Available" or "Unknown").
- Options: Hardcoded (dashboard always shows 3 MCP names, no status checking), Dynamic (orchestrator logs MCP availability checks, dashboard displays real status).
- Recommendation: Hardcoded for Iteration 1 (MCP status checking is Iteration 2 feature, keeps dashboard simple)

**Q5: Should dashboard be regenerated if requirements change?**
- Context: If user modifies project name in config.yaml, dashboard still shows old name.
- Options: One-time generation (dashboard created once, never updated, user can manually delete to regenerate), Regenerate on config change (dashboard detects config changes and updates, requires config versioning).
- Recommendation: One-time generation (user can delete dashboard to force regeneration if needed)

---

**Exploration completed: 2025-10-03**

**Key Takeaway:** Dashboard architecture is straightforward (single-file HTML polling JSONL), but integration with 2l-mvp.md requires careful insertion of event logging hooks at 8+ orchestration points. Biggest risk is breaking existing orchestration flow; mitigation is thorough testing with backward compatibility checks. Dashboard builder agent should generate HTML in single pass (not split) to maintain cohesion of HTML/CSS/JS. Event logger library is simple (approximately 50 lines Bash) and should be built first as dependency for both dashboard and orchestration integration.
